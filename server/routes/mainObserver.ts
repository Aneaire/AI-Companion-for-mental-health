// mainObserver.ts (Main Chat Page Observer - for therapy sessions)
import { GoogleGenerativeAI } from "@google/generative-ai";
import { zValidator } from "@hono/zod-validator";
import fs from "fs";
import { Hono } from "hono";
import path from "path";
import { z } from "zod";
import { geminiConfig } from "../lib/config";
import { logger } from "../lib/logger";

// Initialize Gemini
const gemini = new GoogleGenerativeAI(process.env.GEMINI_API_KEY!);

// Main observer logging function
const logMainObserverCall = async (
  messages: { text: string; sender: string }[],
  geminiResponse: {
    sentiment: string;
    strategy: string;
    rationale: string;
    next_steps: string[];
  },
  initialForm?: {
    preferredName?: string;
    currentEmotions?: string[];
    reasonForVisit?: string;
    supportType?: string[];
    additionalContext?: string;
  },
  followupForm?: Record<string, any>
) => {
  try {
    // Create main_observer_logs directory if it doesn't exist
    const logsDir = path.join(process.cwd(), "main_observer_logs");
    await fs.promises.mkdir(logsDir, { recursive: true });

    // Generate filename with current date and time
    const now = new Date();
    const dateStr = now.toISOString().split("T")[0]; // YYYY-MM-DD
    const timeStr = now
      .toLocaleTimeString("en-US", {
        hour12: true,
        hour: "numeric",
        minute: "2-digit",
        second: "2-digit",
      })
      .replace(/:/g, "-")
      .replace(/\s/g, "_"); // 1:23:45 PM -> 1-23-45_PM
    const filename = `main_${dateStr}_at_${timeStr}.md`;
    const filepath = path.join(logsDir, filename);

    // Format the log content
    const logContent = `# Main Observer Call Log - ${dateStr} at ${timeStr}

## Input Messages
${messages
  .map(
    (msg, index) => `### Message ${index + 1}
**Sender:** ${msg.sender}
**Text:** ${msg.text}
`
  )
  .join("\n")}

## Initial Form Data
${
  initialForm
    ? `
- **Preferred Name:** ${initialForm.preferredName || "Not provided"}
- **Current Emotions:** ${
        initialForm.currentEmotions?.join(", ") || "Not provided"
      }
- **Reason for Visit:** ${initialForm.reasonForVisit || "Not provided"}
- **Support Type:** ${initialForm.supportType?.join(", ") || "Not provided"}
- **Additional Context:** ${initialForm.additionalContext || "Not provided"}
`
    : "No initial form data provided"
}

## Follow-up Form Data (from Previous Session)
${
  followupForm
    ? Object.entries(followupForm)
        .map(([key, value]) => {
          // Convert technical field names to human-readable format
          const humanReadableKey = key
            .replace(/([A-Z])/g, ' $1')
            .replace(/^./, str => str.toUpperCase())
            .replace(/_/g, ' ');
          const formattedValue = typeof value === "string" ? value : JSON.stringify(value);
          return `- **${humanReadableKey}:** ${formattedValue}`;
        })
        .join("\n")
    : "No follow-up form data provided"
}

## Gemini Response
### Sentiment
${geminiResponse.sentiment}

### Strategy
${geminiResponse.strategy}

### Rationale
${geminiResponse.rationale}

### Next Steps
${geminiResponse.next_steps
  .map((step, index) => `${index + 1}. ${step}`)
  .join("\n")}

---
*Generated by Main Observer API at ${now.toISOString()}*
`;

    // Write to file
    await fs.promises.writeFile(filepath, logContent, "utf8");
  } catch (error) {
    logger.error("❌ Error saving main observer log:", error);
    logger.error(
      "❌ Error details:",
      error instanceof Error ? error.message : String(error)
    );
  }
};

// Define schema for main observer request
export const mainObserverRequestSchema = z.object({
  messages: z.array(
    z.object({
      text: z.string(),
      sender: z.enum(["user", "ai"]), // Ensure sender type is either 'user' or 'ai'
    })
  ),
  initialForm: z
    .object({
      // Add initial form context for richer analysis
      preferredName: z.string().optional(),
      currentEmotions: z.array(z.string()).optional(),
      reasonForVisit: z.string().optional(),
      supportType: z.array(z.string()).optional(),
      additionalContext: z.string().optional(),
    })
    .optional(),
  followupForm: z.record(z.any()).optional(), // Add follow-up form data
});

export const mainObserverResponseSchema = z.object({
  sentiment: z.enum(["positive", "negative", "neutral", "urgent", "confused", "crisis_risk"]), // Added crisis_risk
  strategy: z.string(),
  rationale: z.string(),
  next_steps: z.array(z.string()),
});

const mainObserver = new Hono().post(
  "/",
  zValidator("json", mainObserverRequestSchema),
  async (c) => {
    const parsed = mainObserverRequestSchema.safeParse(await c.req.json());
    if (!parsed.success) {
      logger.error("Main Observer Zod validation error:", parsed.error.errors);
      return c.json({ error: JSON.stringify(parsed.error.errors) }, 400);
    }

    const { messages, initialForm, followupForm } = parsed.data;

    try {
      // Use Gemini for sentiment and strategy analysis
      const { sentiment, strategy, rationale, next_steps } =
        await analyzeWithMainGemini(messages, initialForm, followupForm);

      // Log the observer call
      await logMainObserverCall(
        messages,
        {
          sentiment,
          strategy,
          rationale,
          next_steps,
        },
        initialForm,
        followupForm
      );

      return c.json({ sentiment, strategy, rationale, next_steps });
    } catch (error) {
      logger.error("Error in main observer analysis:", error);
      return c.json({
        sentiment: "neutral",
        strategy: "Continue with supportive therapeutic conversation",
        rationale:
          "Unable to analyze sentiment, maintaining supportive therapeutic approach",
        next_steps: ["Continue active listening and providing therapeutic support"],
      });
    }
  }
);

// --- Gemini-powered Analysis for Main Chat ---
async function analyzeWithMainGemini(
  messages: { text: string; sender: string }[],
  initialForm?: {
    preferredName?: string;
    currentEmotions?: string[];
    reasonForVisit?: string;
    supportType?: string[];
    additionalContext?: string;
  },
  followupForm?: Record<string, any>
): Promise<{
  sentiment: "positive" | "negative" | "neutral" | "urgent" | "confused" | "crisis_risk";
  strategy: string;
  rationale: string;
  next_steps: string[];
}> {
  const model = gemini.getGenerativeModel({
    model: geminiConfig.twoPoint5FlashLite,
  });

  // Build context string from initial form
  let contextString = "";
  if (initialForm) {
    if (initialForm.preferredName)
      contextString += `User's preferred name: ${initialForm.preferredName}\n`;
    if (initialForm.currentEmotions && initialForm.currentEmotions.length > 0) {
      contextString += `User's current emotions: ${initialForm.currentEmotions.join(
        ", "
      )}\n`;
    }
    if (initialForm.reasonForVisit)
      contextString += `User's reason for visit: ${initialForm.reasonForVisit}\n`;
    if (initialForm.supportType && initialForm.supportType.length > 0) {
      contextString += `User's desired support type: ${initialForm.supportType.join(
        ", "
      )}\n`;
    }
    if (initialForm.additionalContext)
      contextString += `Additional context: ${initialForm.additionalContext}\n`;
  }

  // Add follow-up form data if present
  if (followupForm && Object.keys(followupForm).length > 0) {
    contextString += `\nFollow-up Form Answers from Previous Session:\n`;
    for (const [key, value] of Object.entries(followupForm)) {
      // Convert technical field names to human-readable format
      const humanReadableKey = key
        .replace(/([A-Z])/g, ' $1')
        .replace(/^./, str => str.toUpperCase())
        .replace(/_/g, ' ');
      const formattedValue = typeof value === "string" ? value : JSON.stringify(value);
      contextString += `${humanReadableKey}: ${formattedValue}\n`;
    }
  }

  // Get recent conversation (last 5 messages for context)
  const recentMessages = messages.slice(-5);
  const conversationText = recentMessages
    .map((msg) => `${msg.sender === "user" ? "User" : "AI Therapist"}: ${msg.text}`)
    .join("\n");

  const prompt = `You are an AI mental health strategist analyzing a therapy session conversation to provide guidance for the AI therapist.

Context about the user:
${contextString}

Recent conversation:
${conversationText}

Analyze the user's current emotional state and provide strategic guidance for the AI therapist. Consider:
1. The user's emotional state (positive, negative, neutral, urgent, confused, crisis_risk)
2. What therapeutic approach would be most beneficial right now
3. The best intervention strategy for the AI therapist to take
4. Any signs of crisis or need for immediate intervention
5. **IMPORTANT**: If follow-up form answers are provided, use them to understand the user's progress, concerns, and current state since the last session. This helps identify continuity of care and therapeutic progress.

**Key Strategic Considerations:**
- If follow-up form data shows improvement, acknowledge progress and build on it
- If follow-up form data reveals new concerns or setbacks, address them with appropriate therapeutic interventions
- Use follow-up form insights to personalize the therapeutic approach and show session-to-session continuity
- Consider how the user's previous session experiences should inform the current session strategy

**CRITICAL:** If you detect ANY signs of suicidal thoughts, self-harm, harm to others, or severe crisis, set sentiment to "crisis_risk" immediately.

Respond in this exact JSON format:
{
  "sentiment": "positive|negative|neutral|urgent|confused|crisis_risk",
  "strategy": "A clear, therapeutic strategy for the AI therapist focusing on evidence-based approaches, incorporating follow-up form insights if available",
  "rationale": "Why this therapeutic strategy is appropriate given the user's current state, therapeutic needs, and any progress or concerns from their follow-up form",
  "next_steps": ["Specific therapeutic intervention 1", "Specific therapeutic intervention 2", "Specific therapeutic intervention 3", "Follow-up action"]
}

Focus on evidence-based therapeutic approaches like CBT, DBT, mindfulness, validation therapy, etc. Prioritize safety and crisis intervention if needed. Use follow-up form data to enhance therapeutic continuity and personalization.`;

  const result = await model.generateContent(prompt);
  const response = result.response.text();

  try {
    // Extract JSON from the response
    const jsonMatch = response.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error("No JSON found in response");
    }

    const parsed = JSON.parse(jsonMatch[0]);

    // Validate and return the response
    return {
      sentiment: parsed.sentiment || "neutral",
      strategy: parsed.strategy || "Continue with supportive therapeutic conversation",
      rationale: parsed.rationale || "Maintaining evidence-based therapeutic approach",
      next_steps: Array.isArray(parsed.next_steps)
        ? parsed.next_steps
        : ["Continue active listening and therapeutic support"],
    };
  } catch (parseError) {
    logger.error("Error parsing Main Gemini response:", parseError);
    logger.error("Raw response:", response);

    // Fallback to therapeutic analysis
    return {
      sentiment: "neutral",
      strategy: "Continue with supportive therapeutic conversation",
      rationale: "Unable to parse AI analysis, maintaining evidence-based therapeutic approach",
      next_steps: ["Continue active listening and therapeutic support"],
    };
  }
}

export default mainObserver;
export type MainObserverType = typeof mainObserver;