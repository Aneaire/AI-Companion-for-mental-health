// impersonateObserver.ts (Impersonate Page Observer - for role-playing scenarios)
import { GoogleGenerativeAI } from "@google/generative-ai";
import { zValidator } from "@hono/zod-validator";
import fs from "fs";
import { Hono } from "hono";
import path from "path";
import { z } from "zod";
import { geminiConfig } from "../lib/config";

// Initialize Gemini
const gemini = new GoogleGenerativeAI(process.env.GEMINI_API_KEY!);

// Impersonate observer logging function
const logImpersonateObserverCall = async (
  messages: { text: string; sender: string }[],
  geminiResponse: {
    sentiment: string;
    strategy: string;
    rationale: string;
    next_steps: string[];
  },
  initialForm?: {
    preferredName?: string;
    currentEmotions?: string[];
    reasonForVisit?: string;
    supportType?: string[];
    additionalContext?: string;
  }
) => {
  try {
    // Create impersonate_observer_logs directory if it doesn't exist
    const logsDir = path.join(process.cwd(), "impersonate_observer_logs");

    if (!fs.existsSync(logsDir)) {
      fs.mkdirSync(logsDir, { recursive: true });
    }

    // Generate filename with current date and time
    const now = new Date();
    const dateStr = now.toISOString().split("T")[0]; // YYYY-MM-DD
    const timeStr = now
      .toLocaleTimeString("en-US", {
        hour12: true,
        hour: "numeric",
        minute: "2-digit",
        second: "2-digit",
      })
      .replace(/:/g, "-")
      .replace(/\s/g, "_"); // 1:23:45 PM -> 1-23-45_PM
    const filename = `impersonate_${dateStr}_at_${timeStr}.md`;
    const filepath = path.join(logsDir, filename);

    // Format the log content
    const logContent = `# Impersonate Observer Call Log - ${dateStr} at ${timeStr}

## Input Messages
${messages
  .map(
    (msg, index) => `### Message ${index + 1}
**Sender:** ${msg.sender}
**Text:** ${msg.text}
`
  )
  .join("\n")}

## Initial Form Data
${
  initialForm
    ? `
- **Preferred Name:** ${initialForm.preferredName || "Not provided"}
- **Current Emotions:** ${
        initialForm.currentEmotions?.join(", ") || "Not provided"
      }
- **Reason for Visit:** ${initialForm.reasonForVisit || "Not provided"}
- **Support Type:** ${initialForm.supportType?.join(", ") || "Not provided"}
- **Additional Context:** ${initialForm.additionalContext || "Not provided"}
`
    : "No initial form data provided"
}

## Gemini Response
### Sentiment
${geminiResponse.sentiment}

### Strategy
${geminiResponse.strategy}

### Rationale
${geminiResponse.rationale}

### Next Steps
${geminiResponse.next_steps
  .map((step, index) => `${index + 1}. ${step}`)
  .join("\n")}

---
*Generated by Impersonate Observer API at ${now.toISOString()}*
`;

    // Write to file
    await fs.promises.writeFile(filepath, logContent, "utf8");
  } catch (error) {
    console.error("❌ Error saving impersonate observer log:", error);
    console.error(
      "❌ Error details:",
      error instanceof Error ? error.message : String(error)
    );
  }
};

// Define schema for impersonate observer request
export const impersonateObserverRequestSchema = z.object({
  messages: z.array(
    z.object({
      text: z.string(),
      sender: z.enum(["user", "ai"]), // Ensure sender type is either 'user' or 'ai'
    })
  ),
  initialForm: z
    .object({
      // Add initial form context for richer analysis
      preferredName: z.string().optional(),
      currentEmotions: z.array(z.string()).optional(),
      reasonForVisit: z.string().optional(),
      supportType: z.array(z.string()).optional(),
      additionalContext: z.string().optional(),
    })
    .optional(),
});

export const impersonateObserverResponseSchema = z.object({
  sentiment: z.enum(["positive", "negative", "neutral", "urgent", "confused"]),
  strategy: z.string(),
  rationale: z.string(),
  next_steps: z.array(z.string()),
});

const impersonateObserver = new Hono().post(
  "/",
  zValidator("json", impersonateObserverRequestSchema),
  async (c) => {
    const parsed = impersonateObserverRequestSchema.safeParse(await c.req.json());
    if (!parsed.success) {
      console.error("Impersonate Observer Zod validation error:", parsed.error.errors);
      return c.json({ error: JSON.stringify(parsed.error.errors) }, 400);
    }

    const { messages, initialForm } = parsed.data;

    try {
      // Use Gemini for sentiment and strategy analysis
      const { sentiment, strategy, rationale, next_steps } =
        await analyzeWithImpersonateGemini(messages, initialForm);

      // Log the observer call
      await logImpersonateObserverCall(
        messages,
        {
          sentiment,
          strategy,
          rationale,
          next_steps,
        },
        initialForm
      );

      return c.json({ sentiment, strategy, rationale, next_steps });
    } catch (error) {
      console.error("Error in impersonate observer analysis:", error);
      return c.json({
        sentiment: "neutral",
        strategy: "Continue with supportive conversation",
        rationale:
          "Unable to analyze sentiment, maintaining supportive approach",
        next_steps: ["Continue listening and providing support"],
      });
    }
  }
);

// --- Gemini-powered Analysis for Impersonate Chat ---
async function analyzeWithImpersonateGemini(
  messages: { text: string; sender: string }[],
  initialForm?: {
    preferredName?: string;
    currentEmotions?: string[];
    reasonForVisit?: string;
    supportType?: string[];
    additionalContext?: string;
  }
): Promise<{
  sentiment: "positive" | "negative" | "neutral" | "urgent" | "confused";
  strategy: string;
  rationale: string;
  next_steps: string[];
}> {
  const model = gemini.getGenerativeModel({
    model: geminiConfig.twoPoint5FlashLite,
  });

  // Build context string from initial form
  let contextString = "";
  if (initialForm) {
    if (initialForm.preferredName)
      contextString += `User's preferred name: ${initialForm.preferredName}\n`;
    if (initialForm.currentEmotions && initialForm.currentEmotions.length > 0) {
      contextString += `User's current emotions: ${initialForm.currentEmotions.join(
        ", "
      )}\n`;
    }
    if (initialForm.reasonForVisit)
      contextString += `User's reason for visit: ${initialForm.reasonForVisit}\n`;
    if (initialForm.supportType && initialForm.supportType.length > 0) {
      contextString += `User's desired support type: ${initialForm.supportType.join(
        ", "
      )}\n`;
    }
    if (initialForm.additionalContext)
      contextString += `Additional context: ${initialForm.additionalContext}\n`;
  }

  // Get recent conversation (last 5 messages for context)
  const recentMessages = messages.slice(-5);
  const conversationText = recentMessages
    .map((msg) => `${msg.sender === "user" ? "User" : "AI"}: ${msg.text}`)
    .join("\n");

  const prompt = `You are an AI strategist analyzing a role-playing conversation to provide guidance for the AI companion in an impersonation scenario.

Context about the user:
${contextString}

Recent conversation:
${conversationText}

Analyze the user's current emotional state and provide strategic guidance for the AI companion in this role-playing context. Consider:
1. The user's emotional state (positive, negative, neutral, urgent, confused)
2. What the user needs most right now in this impersonation scenario
3. The best approach for the AI companion to take while staying in character

Respond in this exact JSON format:
{
  "sentiment": "positive|negative|neutral|urgent|confused",
  "strategy": "A clear, actionable strategy for the AI companion in this role-playing scenario",
  "rationale": "Why this strategy is appropriate given the user's state in the impersonation context",
  "next_steps": ["Step 1", "Step 2", "Step 3", "Step 4"]
}

Focus on maintaining the role-play while being empathetic and supportive. Adapt to the impersonation context while ensuring user engagement.`;

  const result = await model.generateContent(prompt);
  const response = result.response.text();

  try {
    // Extract JSON from the response
    const jsonMatch = response.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error("No JSON found in response");
    }

    const parsed = JSON.parse(jsonMatch[0]);

    // Validate and return the response
    return {
      sentiment: parsed.sentiment || "neutral",
      strategy: parsed.strategy || "Continue with supportive conversation",
      rationale: parsed.rationale || "Maintaining supportive approach",
      next_steps: Array.isArray(parsed.next_steps)
        ? parsed.next_steps
        : ["Continue listening and providing support"],
    };
  } catch (parseError) {
    console.error("Error parsing Impersonate Gemini response:", parseError);
    console.error("Raw response:", response);

    // Fallback to basic analysis
    return {
      sentiment: "neutral",
      strategy: "Continue with supportive conversation",
      rationale: "Unable to parse AI analysis, maintaining supportive approach",
      next_steps: ["Continue listening and providing support"],
    };
  }
}

export default impersonateObserver;
export type ImpersonateObserverType = typeof impersonateObserver;